# =============================================================================
# STREAMLIT APP - Portfolio Optimization (Hybrid Strategy)
# Filename: app.py
# Repo: SORADATA/CAC40-Quantitative-Analysis-Predictive-Asset-Allocation
# =============================================================================

import streamlit as st
import pandas as pd
import numpy as np
import plotly.graph_objects as go
import plotly.express as px
import yfinance as yf  # Library for Live Prices
from datetime import datetime
import pytz

# -----------------------------------------------------------------------------
# 1. PAGE CONFIGURATION
# -----------------------------------------------------------------------------
st.set_page_config(
    page_title=" CAC40 Smart Portfolio",
    page_icon="favicon.jpg", 
    layout="wide",
    initial_sidebar_state="expanded"
)

# Custom CSS for "Hedge Fund" look (Dark Mode Tech)
st.markdown("""
<style>
    .metric-card {
        background-color: #1E1E1E;
        padding: 15px;
        border-radius: 10px;
        border-left: 5px solid #4ECDC4;
    }
    .stMetric label { color: #aaaaaa; }
    .stMetric value { color: #ffffff; }
    div[data-testid="stDataFrame"] { width: 100%; }
</style>
""", unsafe_allow_html=True)

# -----------------------------------------------------------------------------
# 2. DATA LOADING (LIVE MODE VIA GITHUB)
# -----------------------------------------------------------------------------

@st.cache_data(ttl=900)  # 15 min cache
def load_data():
    """
    Loads REAL data generated by GitHub Actions.
    """
    # --- OFFICIAL URL BASED ON YOUR REPO ---
    base_url = "https://raw.githubusercontent.com/SORADATA/CAC40-Quantitative-Analysis-Predictive-Asset-Allocation/main/"

    # A. Portfolio History
    try:
        history_url = base_url + "portfolio_history.csv"
        history_df = pd.read_csv(history_url, index_col=0, parse_dates=True)
        history_df.index.name = 'Date'
        history_df = history_df.sort_index()
    except Exception as e:
        history_df = pd.DataFrame(columns=['Strategy', 'Benchmark'])

    # B. Latest Signals
    try:
        signals_url = base_url + "latest_signals.csv"
        signals_df = pd.read_csv(signals_url)
    except Exception as e:
        signals_df = pd.DataFrame()

    return history_df, signals_df

# Load data
history_df, latest_signals = load_data()

# Calculate Real-Time Metrics
if not history_df.empty and len(history_df) > 1:
    cum_strat = history_df['Strategy'].iloc[-1] - 1
    cum_bench = history_df['Benchmark'].iloc[-1] - 1
    alpha = cum_strat - cum_bench
    
    peak = history_df['Strategy'].cummax()
    drawdown = (history_df['Strategy'] - peak) / peak
    max_dd = drawdown.min()
    
    daily_ret = history_df['Strategy'].pct_change()
    if daily_ret.std() != 0:
        sharpe = (daily_ret.mean() / daily_ret.std()) * np.sqrt(252)
    else:
        sharpe = 0
else:
    cum_strat, cum_bench, alpha, max_dd, sharpe = 0, 0, 0, 0, 0
    drawdown = pd.Series(dtype=float)
    daily_ret = pd.Series(dtype=float)

# -----------------------------------------------------------------------------
# 3. SIDEBAR
# -----------------------------------------------------------------------------
# Logo Display
st.sidebar.image("https://cdn-icons-png.flaticon.com/512/2621/2621020.png", width=80)

st.sidebar.title("")
st.sidebar.markdown("**CAC40 Quantitative Optimizer**")
st.sidebar.caption("*Powered by XGBoost + K-Means + Markowitz*")

# GitHub Badge
st.sidebar.markdown(
    """
    <div style='text-align: center; padding: 10px 0;'>
        <a href='https://github.com/SORADATA/CAC40-Quantitative-Analysis-Predictive-Asset-Allocation' target='_blank' style='text-decoration: none;'>
            <img src='https://img.shields.io/badge/GitHub-SORADATA%2FCAC40-blue?logo=github&style=for-the-badge' />
        </a>
    </div>
    """,
    unsafe_allow_html=True
)

st.sidebar.markdown("---")

# Navigation
page = st.sidebar.radio("Navigation", [" Dashboard & Performance", " Daily Signals", "‚öôÔ∏è Model Details"])

st.sidebar.markdown("---")
st.sidebar.success("‚úÖ **System Status**: ONLINE")
st.sidebar.info(f"üìÖ **Data Date**: {datetime.now().strftime('%d/%m/%Y')}")

# -----------------------------------------------------------------------------
# PAGE 1: DASHBOARD
# -----------------------------------------------------------------------------
if page == " Dashboard & Performance":
    st.title(" Live Performance")
    
    if history_df.empty or len(history_df) < 2:
        st.info("üëã Welcome! System initialized. History will appear after the next daily update.")
    
    # KPIs
    kpi1, kpi2, kpi3, kpi4 = st.columns(4)
    with kpi1: st.metric("Alpha (vs Bench)", f"{alpha:.1%}", delta=f"{alpha*100:.1f} pts")
    with kpi2: st.metric("Sharpe Ratio", f"{sharpe:.2f}", delta="Risk Adj.")
    
    with kpi3: 
        st.metric(
            label=" Max Historical Loss", 
            value=f"{max_dd:.1%}", 
            # max_dd est n√©gatif (ex: -30%) -> Fl√®che BAS par d√©faut
            delta=f"{max_dd:.1%}",  
            # "normal" -> N√©gatif = ROUGE
            delta_color="normal"   
        )
    # ------------------------

    with kpi4: st.metric("Total Return", f"{cum_strat:.1%}", delta="Net of fees")

    st.markdown("---")

    if not history_df.empty:
        st.subheader("üìà Strategy Evolution")
        fig_perf = go.Figure()
        
        fig_perf.add_trace(go.Scatter(
            x=history_df.index, y=history_df['Benchmark'],
            mode='lines', name='Benchmark (CAC40)',
            line=dict(color='gray', width=1.5)
        ))
        
        fig_perf.add_trace(go.Scatter(
            x=history_df.index, y=history_df['Strategy'],
            mode='lines', name='Hybrid Strategy',
            line=dict(color='#2E86AB', width=2.5)
        ))
        
        fig_perf.add_trace(go.Scatter(
            x=history_df.index, y=history_df['Strategy'],
            fill='tonexty', fillcolor='rgba(46, 134, 171, 0.1)',
            line=dict(width=0), showlegend=False
        ))

        fig_perf.update_layout(template="plotly_dark", height=500, legend=dict(orientation="h", y=1.02))
        st.plotly_chart(fig_perf, width="stretch")

        col_dd, col_dist = st.columns(2)
        with col_dd:
            st.subheader("üìâ Drawdown Analysis")
            if not drawdown.empty:
                fig_dd = go.Figure()
                fig_dd.add_trace(go.Scatter(
                    x=drawdown.index, y=drawdown,
                    fill='tozeroy', fillcolor='rgba(231, 76, 60, 0.5)',
                    line=dict(color='#E74C3C', width=1), name='Drawdown'
                ))
                fig_dd.update_layout(template="plotly_dark", height=350)
                st.plotly_chart(fig_dd, width="stretch")

        with col_dist:
            st.subheader("üìä Return Distribution")
            if not daily_ret.empty:
                fig_hist = px.histogram(daily_ret.dropna(), nbins=50, color_discrete_sequence=['#4ECDC4'])
                fig_hist.update_layout(template="plotly_dark", height=350, showlegend=False)
                st.plotly_chart(fig_hist, width="stretch")

# -----------------------------------------------------------------------------
# PAGE 2: SIGNALS 
# -----------------------------------------------------------------------------
elif page == " Daily Signals":
    st.title("ü§ñ ML Investment Signals")
    st.markdown("Signals generated at **18:00 UTC** via GitHub Actions.")
    
    if latest_signals.empty:
        st.warning("‚ö†Ô∏è No signals available yet (Run the GitHub Action first).")
    else:
        col1, col2 = st.columns([2, 1])
        
        with col1:
            st.subheader(" Investment Watchlist (Active Only)")
            
            # --- INPUT CAPITAL ---
            capital = st.number_input(
                "üí∞ Capital to Invest (‚Ç¨)", 
                min_value=100, 
                value=1000, 
                step=100,
                help="Enter your total capital to calculate exact share quantities."
            )
            st.markdown("---")

            # --- FILTERING LOGIC ---
            if 'Allocation' in latest_signals.columns:
                active_signals = latest_signals[latest_signals['Allocation'] > 0.001].copy()
            else:
                active_signals = latest_signals[latest_signals['Signal'].isin(['ACHAT', 'BUY'])].copy()

            if active_signals.empty:
                st.info("üò¥ Strategy is currently **100% CASH**. No stocks to buy today.")
            else:
                # --- FETCH LIVE PRICES ---
                with st.spinner('Fetching live prices & calculating...'):
                    try:
                        tickers_list = active_signals['Ticker'].tolist()
                        if tickers_list:
                            live_data = yf.download(tickers_list, period="1d", progress=False)['Close']
                            
                            if isinstance(live_data, pd.Series):
                                current_prices = {tickers_list[0]: live_data.iloc[-1]}
                            elif not live_data.empty:
                                current_prices = live_data.iloc[-1].to_dict()
                            else:
                                current_prices = {}
                            
                            active_signals['Last Price'] = active_signals['Ticker'].map(current_prices)
                        else:
                            active_signals['Last Price'] = 0.0
                    except Exception as e:
                        active_signals['Last Price'] = 0.0

                # --- CALCULATIONS ---
                if 'Allocation' in active_signals.columns:
                    # Amount = Allocation * Capital
                    active_signals['Invest (‚Ç¨)'] = active_signals['Allocation'] * capital
                    # Shares = Amount / Price (Floored)
                    active_signals['Shares (Qt√©)'] = np.where(
                        active_signals['Last Price'] > 0,
                        np.floor(active_signals['Invest (‚Ç¨)'] / active_signals['Last Price']),
                        0
                    )
                else:
                    active_signals['Invest (‚Ç¨)'] = 0
                    active_signals['Shares (Qt√©)'] = 0

                # --- DISPLAY ---
                desired_order = ['Ticker', 'Last Price', 'Proba_Hausse', 'Allocation', 'Invest (‚Ç¨)', 'Shares (Qt√©)']
                final_cols = [c for c in desired_order if c in active_signals.columns]
                active_signals = active_signals[final_cols]

                # Custom Color Function (Dark Green > 70%)
                def color_proba(val):
                    if val >= 0.70: 
                        return 'background-color: #145A32; color: white; font-weight: bold;' # Vert Fonc√©
                    elif val >= 0.60: 
                        return 'background-color: #28B463; color: white;' # Vert Moyen
                    else: 
                        return 'background-color: #D5F5E3; color: black;' # Vert Clair

                # Style Config
                st.dataframe(
                    active_signals.style
                    .format({
                        'Last Price': '{:.2f} ‚Ç¨',
                        'Proba_Hausse': '{:.1%}', 
                        'Allocation': '{:.1%}',
                        'Invest (‚Ç¨)': '**{:.2f} ‚Ç¨**',
                        'Shares (Qt√©)': '{:.0f}'
                    }, na_rep="-")
                    .map(color_proba, subset=['Proba_Hausse'])
                    .background_gradient(subset=['Invest (‚Ç¨)'], cmap='BuGn'),
                    
                    width="stretch",
                    height=400,
                    column_config={
                        "Allocation": st.column_config.NumberColumn(
                            "Target Allocation",
                            help="‚öñÔ∏è Optimized weight (Markowitz).",
                            format="%.1f %%"
                        ),
                        "Proba_Hausse": st.column_config.NumberColumn(
                            "AI Confidence",
                            help=" Probability of upside (XGBoost).",
                            format="%.1f %%"
                        ),
                        "Shares (Qt√©)": st.column_config.NumberColumn(
                            "Shares (Qty)",
                            help="üì¶ Number of full shares to buy. If 0, increase capital."
                        )
                    }
                )
            
        with col2:
            st.subheader(" Asset Allocation")
            if not active_signals.empty and 'Allocation' in active_signals.columns:
                fig_pie = px.pie(
                    active_signals, 
                    values='Allocation', 
                    names='Ticker',
                    hole=0.4,
                    color_discrete_sequence=px.colors.sequential.Tealgrn
                )
                fig_pie.update_layout(template="plotly_dark", showlegend=False)
                st.plotly_chart(fig_pie, width="stretch")
                
                st.success(f"**Total Invested:** {active_signals['Invest (‚Ç¨)'].sum():.2f} ‚Ç¨")
                st.caption(f"Remaining Cash: {capital - active_signals['Invest (‚Ç¨)'].sum():.2f} ‚Ç¨")

# -----------------------------------------------------------------------------
# PAGE 3: DETAILS
# -----------------------------------------------------------------------------
elif page == "‚öôÔ∏è Model Details":
    st.title("‚öôÔ∏è Model Architecture")
    
    st.markdown("""
    ### üß† "Hybrid" Approach
    This model combines Machine Learning and Quantitative Finance:
    """)
    
    c1, c2, c3 = st.columns(3)
    with c1:
        st.info("**1. Filtering (XGBoost)**")
        st.markdown("Predicts 1-month upside probability (Target > 0%). Confidence Threshold: **55-60%**.")
    with c2:
        st.warning("**2. Profiling (K-Means)**")
        st.markdown("Clusters stocks by market regime. We target **Cluster 3 (Momentum)**.")
    with c3:
        st.success("**3. Allocation (Markowitz)**")
        st.markdown("Optimizes weights (Max Sharpe Ratio) with diversification constraint (Max 25%).")

    st.markdown("---")
    
    # --- MODEL METRICS SECTION (JSON) ---
    st.subheader("üìä Model Performance (Backtest)")
    st.markdown("Metrics from Cross-Validation (GridSearch) on test data.")

    # Load JSON from GitHub
    @st.cache_data(ttl=900)
    def load_metrics():
        base_url = "https://raw.githubusercontent.com/SORADATA/CAC40-Quantitative-Analysis-Predictive-Asset-Allocation/main/"
        try:
            url = base_url + "src/models/metrics.json"
            metrics = pd.read_json(url, typ='series')
            return metrics
        except Exception as e:
            return None

    metrics = load_metrics()

    if metrics is not None:
        # Display KPIs
        k1, k2, k3 = st.columns(3)
        
        accuracy = metrics.get('accuracy', 0)
        auc = metrics.get('auc_score', 0)
        date_train = metrics.get('training_date', 'Unknown')

        with k1:
            st.metric("Accuracy (Test)", f"{accuracy:.1%}", delta="vs Random (50%)")
        with k2:
            st.metric("ROC AUC Score", f"{auc:.3f}", delta="Discriminant Quality")
        with k3:
            st.metric("Last Training", date_train)
            
        # Display Hyperparameters
        with st.expander("üîç View Optimal Hyperparameters (Best Params)"):
            st.json(metrics['best_params'])
            
    else:
        st.warning("‚ö†Ô∏è Model metrics (metrics.json) are not yet available on GitHub.")

    st.markdown("---")
    st.subheader("3. Fundamental Cluster Analysis (Simulation)")
    
    # Pedagogical Simulation
    np.random.seed(42)
    n_points = 200
    df_analysis = pd.DataFrame({
        'Cluster': np.random.choice([0, 1, 2, 3], n_points),
        'Ticker': [f'STOCK_{i}' for i in range(n_points)]
    })
    def generate_return(cluster):
        if cluster == 0: return np.random.normal(0.05, 0.1)
        if cluster == 1: return np.random.normal(0.02, 0.15)
        if cluster == 2: return np.random.normal(0.10, 0.2)
        if cluster == 3: return np.random.normal(0.25, 0.25)
        return 0
    df_analysis['return_6m'] = df_analysis['Cluster'].apply(generate_return)
    cluster_map = {0: '0 - Defensive üõ°Ô∏è', 1: '1 - Value üí∞', 2: '2 - Growth üìà', 3: '3 - Momentum üöÄ'}
    df_analysis['Label'] = df_analysis['Cluster'].map(cluster_map)

    fig_box = px.box(
        df_analysis, x='Label', y='return_6m', color='Label',
        title="Return Distribution by Cluster (Theoretical)",
        color_discrete_map={'0 - Defensive üõ°Ô∏è': '#95a5a6', '1 - Value üí∞': '#3498db', '2 - Growth üìà': '#f1c40f', '3 - Momentum üöÄ': '#2ecc71'}
    )
    fig_box.update_layout(template="plotly_dark", showlegend=False, height=450)
    st.plotly_chart(fig_box, width="stretch")

# -----------------------------------------------------------------------------
# DISCLAIMER (Sidebar)
# -----------------------------------------------------------------------------
st.sidebar.markdown("---")
with st.sidebar.expander("‚ö†Ô∏è Disclaimer", expanded=False):
    st.caption("""
    **Educational Project - Master 2**
    
    This application is developed for strictly educational and academic research purposes.
    
    Predictions (Signals, Allocations) are generated by AI models (XGBoost, K-Means) and do not constitute financial investment advice.
    
    **Risks:** Investing in the stock market involves risks of capital loss. Past performance is not indicative of future results.
    
    The author declines all responsibility regarding the use of information provided here.
    """)